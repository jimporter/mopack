{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"mopack \u00a7 mopack (pronounced \"ammopack\") is a multiple origin package manager, with an emphasis on C/C++ packages. It's designed to allow users to resolve package dependencies from multiple package managers (\"origins\"). Why mopack? \u00a7 Separate abstract and concrete dependencies \u00a7 Generally speaking, developers of a project are more concerned about dependencies in the abstract: if your project requires Boost v1.50+, that's all that really matters. However, when building a project, you work with concrete dependencies: you naturally have to download a particular version of Boost and build/install it in a particular way. mopack supports this by letting a project's build system asking how to use (link to) an abstract dependency, which mopack will resolve via a particular concrete dependency. No configuration necessary \u00a7 If you've already downloaded and installed a project's dependencies, you usually don't need to do anything else. mopack can find dependencies using common methods for the relevant platform (e.g. pkg-config, searching system paths). Easy overrides \u00a7 To simplify building their project, developers can provide a default mopack configuration so that a standard build just works without any extra effort. However, people who build the project may prefer to resolve packages from somewhere else. mopack makes this easy: simply pass in an extra mopack file with new definitions for any dependency, and mopack will use those instead. Installation \u00a7 mopack uses setuptools , so installation is much the same as any other Python package: $ pip install mopack If you've downloaded mopack already, just run pip install . from the source directory. (Equivalently, you can run python setup.py install .) From there, you can start using mopack to build your software!","title":"Home"},{"location":"#mopack","text":"mopack (pronounced \"ammopack\") is a multiple origin package manager, with an emphasis on C/C++ packages. It's designed to allow users to resolve package dependencies from multiple package managers (\"origins\").","title":"mopack"},{"location":"#why-mopack","text":"","title":"Why mopack?"},{"location":"#separate-abstract-and-concrete-dependencies","text":"Generally speaking, developers of a project are more concerned about dependencies in the abstract: if your project requires Boost v1.50+, that's all that really matters. However, when building a project, you work with concrete dependencies: you naturally have to download a particular version of Boost and build/install it in a particular way. mopack supports this by letting a project's build system asking how to use (link to) an abstract dependency, which mopack will resolve via a particular concrete dependency.","title":"Separate abstract and concrete dependencies"},{"location":"#no-configuration-necessary","text":"If you've already downloaded and installed a project's dependencies, you usually don't need to do anything else. mopack can find dependencies using common methods for the relevant platform (e.g. pkg-config, searching system paths).","title":"No configuration necessary"},{"location":"#easy-overrides","text":"To simplify building their project, developers can provide a default mopack configuration so that a standard build just works without any extra effort. However, people who build the project may prefer to resolve packages from somewhere else. mopack makes this easy: simply pass in an extra mopack file with new definitions for any dependency, and mopack will use those instead.","title":"Easy overrides"},{"location":"#installation","text":"mopack uses setuptools , so installation is much the same as any other Python package: $ pip install mopack If you've downloaded mopack already, just run pip install . from the source directory. (Equivalently, you can run python setup.py install .) From there, you can start using mopack to build your software!","title":"Installation"},{"location":"about/changes/","text":"Changes \u00a7 v0.2.0 \u00a7 in progress v0.1.0 \u00a7 2023-05-15 Initial release","title":"Changes"},{"location":"about/changes/#changes","text":"","title":"Changes"},{"location":"about/changes/#v020","text":"in progress","title":"v0.2.0"},{"location":"about/changes/#v010","text":"2023-05-15 Initial release","title":"v0.1.0"},{"location":"about/license/","text":"License \u00a7 BSD 3-clause license \u00a7 Copyright (c) 2020-2023, Jim Porter All rights reserved. Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met: Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution. Neither the name of the copyright holder nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission. THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.","title":"License"},{"location":"about/license/#license","text":"","title":"License"},{"location":"about/license/#bsd-3-clause-license","text":"Copyright (c) 2020-2023, Jim Porter All rights reserved. Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met: Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution. Neither the name of the copyright holder nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission. THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.","title":"BSD 3-clause license"},{"location":"reference/builders/","text":"Builders \u00a7 Builders define how source distributions should be built, allowing you to build dependencies from source even if they use a different build system. packages: my_pkg: # ... build: <builder_type> # or... build: type: <builder_type> type required The type of builder; see below for possible values. bfg9000 \u00a7 options: builders: bfg9000: toolchain: <path> toolchain optional, default : null The path to a bfg9000 toolchain file to use when building bfg-based dependencies. packages: my_pkg: # ... builder: type: bfg9000 extra_args: <shell_args> extra_args optional, default : null A list of extra arguments to pass to bfg9000 configure . If a string is supplied, it will first be split according to POSIX shell rules. cmake \u00a7 options: builders: cmake: toolchain: <path> toolchain optional, default : null The path to a CMake toolchain file to use when building CMake-based dependencies. packages: my_pkg: # ... builder: type: cmake extra_args: <shell_args> extra_args optional, default : null A list of extra arguments to pass to cmake . If a string is supplied, it will first be split according to POSIX shell rules. custom \u00a7 packages: my_pkg: # ... builder: type: custom build_commands: <list[shell_args]> deploy_commands: <list[shell_args]> build_commands optional, default : null A list of shell commands to execute when building the dependency. Each command can be a list of arguments or a single string (which will be split into arguments according to POSIX shell rules). deploy_commands optional, default : null A list of shell commands to execute when deploying the dependency. Each command can be a list of arguments or a single string (which will be split into arguments according to POSIX shell rules). none \u00a7 packages: my_pkg: # ... builder: type: none","title":"Builders"},{"location":"reference/builders/#builders","text":"Builders define how source distributions should be built, allowing you to build dependencies from source even if they use a different build system. packages: my_pkg: # ... build: <builder_type> # or... build: type: <builder_type> type required The type of builder; see below for possible values.","title":"Builders"},{"location":"reference/builders/#bfg9000","text":"options: builders: bfg9000: toolchain: <path> toolchain optional, default : null The path to a bfg9000 toolchain file to use when building bfg-based dependencies. packages: my_pkg: # ... builder: type: bfg9000 extra_args: <shell_args> extra_args optional, default : null A list of extra arguments to pass to bfg9000 configure . If a string is supplied, it will first be split according to POSIX shell rules.","title":"bfg9000"},{"location":"reference/builders/#cmake","text":"options: builders: cmake: toolchain: <path> toolchain optional, default : null The path to a CMake toolchain file to use when building CMake-based dependencies. packages: my_pkg: # ... builder: type: cmake extra_args: <shell_args> extra_args optional, default : null A list of extra arguments to pass to cmake . If a string is supplied, it will first be split according to POSIX shell rules.","title":"cmake"},{"location":"reference/builders/#custom","text":"packages: my_pkg: # ... builder: type: custom build_commands: <list[shell_args]> deploy_commands: <list[shell_args]> build_commands optional, default : null A list of shell commands to execute when building the dependency. Each command can be a list of arguments or a single string (which will be split into arguments according to POSIX shell rules). deploy_commands optional, default : null A list of shell commands to execute when deploying the dependency. Each command can be a list of arguments or a single string (which will be split into arguments according to POSIX shell rules).","title":"custom"},{"location":"reference/builders/#none","text":"packages: my_pkg: # ... builder: type: none","title":"none"},{"location":"reference/command-line/","text":"Command-Line Reference \u00a7 Global options \u00a7 -h , --help \u00a7 Print a help message and exit. Equivalent to the help subcommand. --verbose \u00a7 Show verbose output, e.g. the output of build commands during mopack resolve . -c , --color WHEN \u00a7 Show colored output; WHEN is one of always , never , or auto and defaults to auto (i.e. show colored output when the terminal is a tty). -c is equivalent to --color=always . --warn-once \u00a7 Only emit a given warning once. Sub-commands \u00a7 mopack help [ SUBCOMMAND ] \u00a7 Print a help message and exit. If SUBCOMMAND is specified, print help for that subcommand. mopack resolve [ FILE ] \u00a7 Fetch dependencies from their origins and prepare them for use by the current project (e.g. by building them). --directory PATH \u00a7 The directory storing the local package data; defaults to ./mopack . -d KIND = DIR , --deploy-dir KIND = DIR \u00a7 Set the directory to deploy package data kind KIND to DIR . KIND is a GNU-like directory variable , such as prefix or bindir . -o OPTION = VALUE , --option OPTION = VALUE \u00a7 Override the common option OPTION to be VALUE . -O OPTION = VALUE , --origin-option OPTION = VALUE \u00a7 Override the origin option OPTION to be VALUE . -B OPTION = VALUE , --builder-option OPTION = VALUE \u00a7 Override the builder option OPTION to be VALUE . --strict \u00a7 Return an error during mopack usage if the requested dependency is not defined. mopack usage [ DEPENDENCY ] \u00a7 Retrieve information about how to use a dependency. This returns metadata in YAML format (or JSON if --json is passed) pointing to a pkg-config .pc file. --directory PATH \u00a7 The directory storing the local package data; defaults to ./mopack . --json \u00a7 Display usage results as JSON. --strict \u00a7 Return an error if the requested dependency is not defined. mopack deploy \u00a7 Copy the project's dependencies to an installation directory (e.g. as part of running a command like make install ). --directory PATH \u00a7 The directory storing the local package data; defaults to ./mopack . mopack clean \u00a7 Clean the mopack package directory of all files. --directory PATH \u00a7 The directory storing the local package data; defaults to ./mopack . mopack list-files \u00a7 List all the input files used by the current configuration. --directory PATH \u00a7 The directory storing the local package data; defaults to ./mopack . --I , --include-implicit \u00a7 Include implicit input files. --json \u00a7 Display results as JSON. --strict \u00a7 Return an error if the package directory does not exist. mopack list-packages , mopack ls \u00a7 List all the package dependencies. --directory PATH \u00a7 The directory storing the local package data; defaults to ./mopack . --flat \u00a7 List packages without hierarchy. mopack generate-completion \u00a7 Generate shell-completion functions for mopack and write them to standard output. This requires the Python package shtab . -s SHELL , --shell SHELL \u00a7 Specify the shell to generate completion for, e.g. bash . Defaults to the current shell's name.","title":"Command-Line Interface"},{"location":"reference/command-line/#command-line-reference","text":"","title":"Command-Line Reference"},{"location":"reference/command-line/#global-options","text":"","title":"Global options"},{"location":"reference/command-line/#help-option","text":"Print a help message and exit. Equivalent to the help subcommand.","title":"-h, --help"},{"location":"reference/command-line/#verbose","text":"Show verbose output, e.g. the output of build commands during mopack resolve .","title":"--verbose"},{"location":"reference/command-line/#color","text":"Show colored output; WHEN is one of always , never , or auto and defaults to auto (i.e. show colored output when the terminal is a tty). -c is equivalent to --color=always .","title":"-c, --color WHEN"},{"location":"reference/command-line/#warn-once","text":"Only emit a given warning once.","title":"--warn-once"},{"location":"reference/command-line/#sub-commands","text":"","title":"Sub-commands"},{"location":"reference/command-line/#help","text":"Print a help message and exit. If SUBCOMMAND is specified, print help for that subcommand.","title":"mopack help [SUBCOMMAND]"},{"location":"reference/command-line/#resolve","text":"Fetch dependencies from their origins and prepare them for use by the current project (e.g. by building them).","title":"mopack resolve [FILE]"},{"location":"reference/command-line/#resolve-directory","text":"The directory storing the local package data; defaults to ./mopack .","title":"--directory PATH"},{"location":"reference/command-line/#resolve-deploy-dir","text":"Set the directory to deploy package data kind KIND to DIR . KIND is a GNU-like directory variable , such as prefix or bindir .","title":"-d KIND=DIR, --deploy-dir KIND=DIR"},{"location":"reference/command-line/#resolve-option","text":"Override the common option OPTION to be VALUE .","title":"-o OPTION=VALUE, --option OPTION=VALUE"},{"location":"reference/command-line/#resolve-origin-option","text":"Override the origin option OPTION to be VALUE .","title":"-O OPTION=VALUE, --origin-option OPTION=VALUE"},{"location":"reference/command-line/#resolve-builder-option","text":"Override the builder option OPTION to be VALUE .","title":"-B OPTION=VALUE, --builder-option OPTION=VALUE"},{"location":"reference/command-line/#resolve-strict","text":"Return an error during mopack usage if the requested dependency is not defined.","title":"--strict"},{"location":"reference/command-line/#usage","text":"Retrieve information about how to use a dependency. This returns metadata in YAML format (or JSON if --json is passed) pointing to a pkg-config .pc file.","title":"mopack usage [DEPENDENCY]"},{"location":"reference/command-line/#usage-directory","text":"The directory storing the local package data; defaults to ./mopack .","title":"--directory PATH"},{"location":"reference/command-line/#usage-json","text":"Display usage results as JSON.","title":"--json"},{"location":"reference/command-line/#usage-strict","text":"Return an error if the requested dependency is not defined.","title":"--strict"},{"location":"reference/command-line/#deploy","text":"Copy the project's dependencies to an installation directory (e.g. as part of running a command like make install ).","title":"mopack deploy"},{"location":"reference/command-line/#deploy-directory","text":"The directory storing the local package data; defaults to ./mopack .","title":"--directory PATH"},{"location":"reference/command-line/#clean","text":"Clean the mopack package directory of all files.","title":"mopack clean"},{"location":"reference/command-line/#clean-directory","text":"The directory storing the local package data; defaults to ./mopack .","title":"--directory PATH"},{"location":"reference/command-line/#list-files","text":"List all the input files used by the current configuration.","title":"mopack list-files"},{"location":"reference/command-line/#list-files-directory","text":"The directory storing the local package data; defaults to ./mopack .","title":"--directory PATH"},{"location":"reference/command-line/#list-files-include-implicit","text":"Include implicit input files.","title":"--I, --include-implicit"},{"location":"reference/command-line/#list-files-json","text":"Display results as JSON.","title":"--json"},{"location":"reference/command-line/#usage-strict","text":"Return an error if the package directory does not exist.","title":"--strict"},{"location":"reference/command-line/#list-packages","text":"List all the package dependencies.","title":"mopack list-packages, mopack ls"},{"location":"reference/command-line/#list-packages-directory","text":"The directory storing the local package data; defaults to ./mopack .","title":"--directory PATH"},{"location":"reference/command-line/#list-packages-flat","text":"List packages without hierarchy.","title":"--flat"},{"location":"reference/command-line/#generate-completion","text":"Generate shell-completion functions for mopack and write them to standard output. This requires the Python package shtab .","title":"mopack generate-completion"},{"location":"reference/command-line/#generate-completion-shell","text":"Specify the shell to generate completion for, e.g. bash . Defaults to the current shell's name.","title":"-s SHELL, --shell SHELL"},{"location":"reference/environment-vars/","text":"Environment Variables \u00a7 mopack reads from a number of environment variables. Below is a full list of all the environment variables mopack recognizes. Command variables \u00a7 ADD_APT_REPOSITORY \u00a7 Default: sudo add-apt-repository The command to use when adding an apt repository. APT_GET \u00a7 Default: sudo apt-get The command to use when installing an apt package. BFG9000 \u00a7 Default: bfg9000 The command to use when configuring a bfg9000 -based project. CONAN \u00a7 Default: conan The command to use when installing a conan package. CMAKE \u00a7 Default: cmake The command to use when configuring a CMake -based project. DPKG_QUERY \u00a7 Default: dpkg-query The command to use when querying an apt package. GIT \u00a7 Default: git The command to use when working with a git repository. NINJA \u00a7 Default: ninja The command to use when building via the Ninja build system. PATCH \u00a7 Default: patch The command to use when applying a patch file. Package variables \u00a7 BOOST_ROOT \u00a7 Default: none The root directory where Boost headers and libraries are stored (as $BOOST_ROOT/include and $BOOST_ROOT/lib , respectively). BOOST_INCLUDEDIR \u00a7 Default: none The root directory where Boost headers are stored. This takes precedence over $BOOST_ROOT . BOOST_LIBRARYDIR \u00a7 Default: none The root directory where Boost libraries are stored. This takes precedence over $BOOST_ROOT . QT_ROOT \u00a7 Default: none The root directory where Qt headers and libraries are stored (as $QT_ROOT/include:$QT_ROOT/include/Qt and $QT_ROOT/lib , respectively). QT_INCLUDEDIR \u00a7 Default: none The root directory where Qt headers are stored. This takes precedence over $QT_ROOT . QT_LIBRARYDIR \u00a7 Default: none The root directory where Qt libraries are stored. This takes precedence over $QT_ROOT . System variables \u00a7 CLICOLOR \u00a7 Default: none If set to 0 , disable colors in terminal output, overriding the --color option and tty detection. If set to non-zero, enable colors if outputting to a tty. CLICOLOR_FORCE \u00a7 Default: none If set to non-zero, enable colors in the terminal output regardless of whether the destination is a tty. This overrides $CLICOLOR .","title":"Environment Variables"},{"location":"reference/environment-vars/#environment-variables","text":"mopack reads from a number of environment variables. Below is a full list of all the environment variables mopack recognizes.","title":"Environment Variables"},{"location":"reference/environment-vars/#command-variables","text":"","title":"Command variables"},{"location":"reference/environment-vars/#add_apt_repository","text":"Default: sudo add-apt-repository The command to use when adding an apt repository.","title":"ADD_APT_REPOSITORY"},{"location":"reference/environment-vars/#apt_get","text":"Default: sudo apt-get The command to use when installing an apt package.","title":"APT_GET"},{"location":"reference/environment-vars/#bfg9000","text":"Default: bfg9000 The command to use when configuring a bfg9000 -based project.","title":"BFG9000"},{"location":"reference/environment-vars/#conan","text":"Default: conan The command to use when installing a conan package.","title":"CONAN"},{"location":"reference/environment-vars/#cmake","text":"Default: cmake The command to use when configuring a CMake -based project.","title":"CMAKE"},{"location":"reference/environment-vars/#dpkg_query","text":"Default: dpkg-query The command to use when querying an apt package.","title":"DPKG_QUERY"},{"location":"reference/environment-vars/#git","text":"Default: git The command to use when working with a git repository.","title":"GIT"},{"location":"reference/environment-vars/#ninja","text":"Default: ninja The command to use when building via the Ninja build system.","title":"NINJA"},{"location":"reference/environment-vars/#patch","text":"Default: patch The command to use when applying a patch file.","title":"PATCH"},{"location":"reference/environment-vars/#package-variables","text":"","title":"Package variables"},{"location":"reference/environment-vars/#boost_root","text":"Default: none The root directory where Boost headers and libraries are stored (as $BOOST_ROOT/include and $BOOST_ROOT/lib , respectively).","title":"BOOST_ROOT"},{"location":"reference/environment-vars/#boost_includedir","text":"Default: none The root directory where Boost headers are stored. This takes precedence over $BOOST_ROOT .","title":"BOOST_INCLUDEDIR"},{"location":"reference/environment-vars/#boost_librarydir","text":"Default: none The root directory where Boost libraries are stored. This takes precedence over $BOOST_ROOT .","title":"BOOST_LIBRARYDIR"},{"location":"reference/environment-vars/#qt_root","text":"Default: none The root directory where Qt headers and libraries are stored (as $QT_ROOT/include:$QT_ROOT/include/Qt and $QT_ROOT/lib , respectively).","title":"QT_ROOT"},{"location":"reference/environment-vars/#qt_includedir","text":"Default: none The root directory where Qt headers are stored. This takes precedence over $QT_ROOT .","title":"QT_INCLUDEDIR"},{"location":"reference/environment-vars/#qt_librarydir","text":"Default: none The root directory where Qt libraries are stored. This takes precedence over $QT_ROOT .","title":"QT_LIBRARYDIR"},{"location":"reference/environment-vars/#system-variables","text":"","title":"System variables"},{"location":"reference/environment-vars/#clicolor","text":"Default: none If set to 0 , disable colors in terminal output, overriding the --color option and tty detection. If set to non-zero, enable colors if outputting to a tty.","title":"CLICOLOR"},{"location":"reference/environment-vars/#clicolor_force","text":"Default: none If set to non-zero, enable colors in the terminal output regardless of whether the destination is a tty. This overrides $CLICOLOR .","title":"CLICOLOR_FORCE"},{"location":"reference/expressions/","text":"Expressions \u00a7 Sometimes, how a dependency should be resolved depends on the system you're using. For example, you would only use apt dependencies on Linux systems. To support this, mopack lets you write your dependency configurations using expressions. Introducing expressions \u00a7 You can introduce expressions with ${{ ... }} , or $ if the expression is just a variable name: packages: my_pkg: # ... build: type: custom build_commands: - ./configure --prefix=${{ deploy_dirs['prefix'] }} usage: type: path # ... compile_flags: -I$srcdir/include When defining the expression for conditional package definitions , this introducer isn't necessary (a conditional is always an expression to begin with): packages: hello: - if: host_platform == 'linux' origin: apt # ... - origin: tarball # ... Literals \u00a7 Within expressions, you can use a variety of literal types: booleans ( true or false ) null values ( null ) integers (decimal digits, possibly preceded by - ) strings (quoted using either ' or \" , and with \\ for escapes) arrays ( [value, ...] ) Operators \u00a7 As you might expect, you can use operators within your expressions to manipulate values. The table below lists all the supported operators, with the precedence and associativity: Precedence Operator Meaning Associativity 1 x[y] Subscript Left 2 !x Logical not Right -x Arithmetic negation Right 3 x * y Multiplication Left x / y Division Left x % y Modulo Left 4 x + y Addition/concatenation Left x - y Subtraction Left 5 x > y Greater than Left x >= y Greater than or equal to Left x < y Less than Left x <= y Less than or equal to Left 6 x == y Equal to Left x != y Not equal to Left 7 x && y Logical and Left x || y Logical or Left 8 x ? y : z Ternary conditional Right Variables \u00a7 mopack provides several variables that you can use within expressions in order to programmatically define how to resolve or use your dependencies. cfgdir availability : everywhere The directory containing the current mopack configuration file. srcdir availability : source distributions The directory containing the source code for the current package. builddir availability : builders , usage The directory to put the compiled output from a source distribution. deploy_dirs availability : everywhere A dictionary of directories specifying where to deploy package data to. These can be specified in the options section. host_platform availability : everywhere The name of the current platform (the one being used to build your project). Possible values include linux , windows , or darwin . target_platform availability : everywhere The name of the platform that binaries are being built for. env availability : everywhere A dictionary of environment variables. These can be set by the calling environment or overridden in the options section. submodule availability : submodule maps The name of the user-specified submodule. You can use this to automatically generate submodule configuration for the * placeholder submodule.","title":"Expressions"},{"location":"reference/expressions/#expressions","text":"Sometimes, how a dependency should be resolved depends on the system you're using. For example, you would only use apt dependencies on Linux systems. To support this, mopack lets you write your dependency configurations using expressions.","title":"Expressions"},{"location":"reference/expressions/#introducing-expressions","text":"You can introduce expressions with ${{ ... }} , or $ if the expression is just a variable name: packages: my_pkg: # ... build: type: custom build_commands: - ./configure --prefix=${{ deploy_dirs['prefix'] }} usage: type: path # ... compile_flags: -I$srcdir/include When defining the expression for conditional package definitions , this introducer isn't necessary (a conditional is always an expression to begin with): packages: hello: - if: host_platform == 'linux' origin: apt # ... - origin: tarball # ...","title":"Introducing expressions"},{"location":"reference/expressions/#literals","text":"Within expressions, you can use a variety of literal types: booleans ( true or false ) null values ( null ) integers (decimal digits, possibly preceded by - ) strings (quoted using either ' or \" , and with \\ for escapes) arrays ( [value, ...] )","title":"Literals"},{"location":"reference/expressions/#operators","text":"As you might expect, you can use operators within your expressions to manipulate values. The table below lists all the supported operators, with the precedence and associativity: Precedence Operator Meaning Associativity 1 x[y] Subscript Left 2 !x Logical not Right -x Arithmetic negation Right 3 x * y Multiplication Left x / y Division Left x % y Modulo Left 4 x + y Addition/concatenation Left x - y Subtraction Left 5 x > y Greater than Left x >= y Greater than or equal to Left x < y Less than Left x <= y Less than or equal to Left 6 x == y Equal to Left x != y Not equal to Left 7 x && y Logical and Left x || y Logical or Left 8 x ? y : z Ternary conditional Right","title":"Operators"},{"location":"reference/expressions/#variables","text":"mopack provides several variables that you can use within expressions in order to programmatically define how to resolve or use your dependencies. cfgdir availability : everywhere The directory containing the current mopack configuration file. srcdir availability : source distributions The directory containing the source code for the current package. builddir availability : builders , usage The directory to put the compiled output from a source distribution. deploy_dirs availability : everywhere A dictionary of directories specifying where to deploy package data to. These can be specified in the options section. host_platform availability : everywhere The name of the current platform (the one being used to build your project). Possible values include linux , windows , or darwin . target_platform availability : everywhere The name of the platform that binaries are being built for. env availability : everywhere A dictionary of environment variables. These can be set by the calling environment or overridden in the options section. submodule availability : submodule maps The name of the user-specified submodule. You can use this to automatically generate submodule configuration for the * placeholder submodule.","title":"Variables"},{"location":"reference/file-structure/","text":"File Structure \u00a7 Mopack files are structured into three main sections: packages , which list the package dependencies and how to resolve them; options , which define various cross-package settings; and exports , which tell other packages how to use the current one. Exports \u00a7 The export section allows a package to declare how other packages should use it as a dependency, when used as a source distribution . export: submodules: <submodules> build: <build> usage: <usage> submodules optional, default : null A list of available submodules, or * to indicate that any submodule name should be accepted. If this is specified, using this package via mopack usage must specify a submodule. To declare that submodules are optional for usage, you can specify a dictionary: submodules: names: <submodules> required: false build optional, default: null The builder to use when resolving this package. If unspecified, other packages using this one will have to define the build in their own mopack configuration. usage optional, default : from builder The usage to use when using this package. Some builders require this to be set, but others provide a default usage specification; if unspecified and the builder requires this to be set, then other packages using this one will need to define it. Options \u00a7 The options section lets you specify project-wide options to configure all your dependencies, or all of those with a particular origin or builder. options: target_platform: <platform> env: <dict> deploy_dirs: <dict> origins: # ... builders: # ... target_platform optional, default : host platform The target platform to build for. This is useful for cross-compilation. Examples of target platforms include: linux , windows , or darwin (macOS). env optional, default: null A dictionary of environment variables and their values to set while resolving dependencies. These override current environment variables of the same name (e.g. from the shell). deploy_dirs optional, default: null A dictionary mapping kinds of deploy directories to their actual locations. Each kind should be one of the GNU directory variables . At the simplest, you can just specify the prefix variable. Note: the exact kinds that are supported depend on the package origin and builder. origins optional, default: null A dictionary of options for specific package origins . builders optional, default: null A dictionary of options for specific package builders . Packages \u00a7 The packages section lists all the package dependencies for your project, as well as how to resolve them. Packages are specified as a dictionary mapping package names to their configurations: packages: my_pkg: origin: <origin> # ... Conditional package definitions \u00a7 You can also specify a list of configurations for a given package; in addition to the usual properties, each element of the list (except the last) must have an if property. mopack will then use the first configuration whose conditional is satisfied: packages: my_pkg: - if: <condition> origin: <origin> # ... - origin: <origin> # ... Conditionals use mopack's expression syntax , though unlike in other contexts, the ${} sigil isn't required: packages: my_pkg: - if: target_platform == 'linux' # ...","title":"File Structure"},{"location":"reference/file-structure/#file-structure","text":"Mopack files are structured into three main sections: packages , which list the package dependencies and how to resolve them; options , which define various cross-package settings; and exports , which tell other packages how to use the current one.","title":"File Structure"},{"location":"reference/file-structure/#exports","text":"The export section allows a package to declare how other packages should use it as a dependency, when used as a source distribution . export: submodules: <submodules> build: <build> usage: <usage> submodules optional, default : null A list of available submodules, or * to indicate that any submodule name should be accepted. If this is specified, using this package via mopack usage must specify a submodule. To declare that submodules are optional for usage, you can specify a dictionary: submodules: names: <submodules> required: false build optional, default: null The builder to use when resolving this package. If unspecified, other packages using this one will have to define the build in their own mopack configuration. usage optional, default : from builder The usage to use when using this package. Some builders require this to be set, but others provide a default usage specification; if unspecified and the builder requires this to be set, then other packages using this one will need to define it.","title":"Exports"},{"location":"reference/file-structure/#options","text":"The options section lets you specify project-wide options to configure all your dependencies, or all of those with a particular origin or builder. options: target_platform: <platform> env: <dict> deploy_dirs: <dict> origins: # ... builders: # ... target_platform optional, default : host platform The target platform to build for. This is useful for cross-compilation. Examples of target platforms include: linux , windows , or darwin (macOS). env optional, default: null A dictionary of environment variables and their values to set while resolving dependencies. These override current environment variables of the same name (e.g. from the shell). deploy_dirs optional, default: null A dictionary mapping kinds of deploy directories to their actual locations. Each kind should be one of the GNU directory variables . At the simplest, you can just specify the prefix variable. Note: the exact kinds that are supported depend on the package origin and builder. origins optional, default: null A dictionary of options for specific package origins . builders optional, default: null A dictionary of options for specific package builders .","title":"Options"},{"location":"reference/file-structure/#packages","text":"The packages section lists all the package dependencies for your project, as well as how to resolve them. Packages are specified as a dictionary mapping package names to their configurations: packages: my_pkg: origin: <origin> # ...","title":"Packages"},{"location":"reference/file-structure/#conditional-package-definitions","text":"You can also specify a list of configurations for a given package; in addition to the usual properties, each element of the list (except the last) must have an if property. mopack will then use the first configuration whose conditional is satisfied: packages: my_pkg: - if: <condition> origin: <origin> # ... - origin: <origin> # ... Conditionals use mopack's expression syntax , though unlike in other contexts, the ${} sigil isn't required: packages: my_pkg: - if: target_platform == 'linux' # ...","title":"Conditional package definitions"},{"location":"reference/packages/","text":"Packages \u00a7 Package configurations describe how to fetch a particular dependency as well as all the necessary details to actually use it in the parent project. packages: my_pkg: origin: <package_origin> inherit_defaults: <boolean> deploy: <boolean> submodules: <submodules> origin required The type of dependency, corresponding to a particular origin (e.g. a package manager); see below for possible values. inherit_defaults optional, default : false If true, inherit any unspecified values for this dependency from the defaults for the package. Defaults to false; however, any packages requested via mopack usage but not defined will use the defaults. deploy optional, default : true If true, deploy this package when calling mopack deploy . submodules optional, default : null A list of available submodules, or * to indicate that any submodule name should be accepted. If this is specified, using this package via mopack usage must specify a submodule. To declare that submodules are optional for usage, you can specify a dictionary: submodules: names: <submodules> required: false This can also be set in a package's export section. Source distributions \u00a7 directory \u00a7 packages: my_pkg: origin: directory path: <path> build: <build> usage: <usage> path required The path to the source directory of the dependency. build required The builder to use when resolving this package. Note that while this is required, it can be unset if the dependency defines the builder in its export section. usage optional, default : from builder The usage to use when using this package. Some builders require this to be set, but others provide a default usage specification; the dependency can also define the usage in its export section. git \u00a7 packages: my_pkg: origin: git repository: <url | path> tag: <tag_name> # or... branch: <branch_name> # or... commit: <commit_sha> srcdir: <inner_path> build: <build> usage: <usage> repository required The URL or path to the repository. tag optional branch commit The tag, branch, or commit to check out. At most one of these may be specified. srcdir optional; default: . The directory within the repository containing the dependency's source code. build required The builder to use when resolving this package. Note that while this is required, it can be unset if the dependency defines the builder in its export section. usage optional, default: from builder The usage to use when using this package. Some builders require this to be set, but others provide a default usage specification; the dependency can also define the usage in its export section. tarball \u00a7 packages: my_pkg: origin: tarball path: <path> # or... url: <url> files: <list[glob]> srcdir: <inner_path> patch: <path> build: <build> usage: <usage> path required url The path or URL to the archive. Exactly one of these must be specified. files optional; default: null A glob or list of globs to filter the files extracted from the archive. If unspecified, extract everything. srcdir optional; default: . The directory within the repository containing the dependency's source code. patch optional; default: null The path to a patch file to apply to the extract source files. build required The builder to use when resolving this package. Note that while this is required, it can be unset if the dependency defines the builder in its export section. usage optional, default: from builder The usage to use when using this package. Some builders require this to be set, but others provide a default usage specification; the dependency can also define the usage in its export section. Other origins \u00a7 apt \u00a7 packages: my_pkg: origin: apt remote: <list[string]> repository: <string> usage: <usage> remote optional; default: lib{package}-dev The Apt package(s) to fetch when resolving this package. repository optional; default: null The Apt repository to fetch the package(s) from. If not specified, use the default repositories for the system. usage optional, default: system The usage to use when using this package. conan \u00a7 options: origins: conan: build: <list[string]> extra_args: <shell_args> build optional; default: null A string (or list of strings) of packages that Conan should explicitly build. This corresponds to --build={package} on the conan install command line for each {package} in the list. You can also specify all to build everything (equivalent to --build ). extra_args optional, default : null A list of extra arguments to pass to conan install . If a string is supplied, it will first be split according to POSIX shell rules. packages: my_pkg: origin: conan remote: <string> build: <boolean> options: my_option: <string | boolean> usage: <usage> remote required The specifier for the package in the Conan repository, e.g. zlib/1.2.13 . build optional; default: false True if the package should be built from source; false otherwise. options optional; default: {} A dictionary of options to pass to Conan; for example, you could pass shared: true to request a shared library configuration. usage optional, default: pkg_config The usage to use when using this package. system \u00a7 packages: my_pkg: origin: system auto_link: <boolean> version: <string> pcname: <string> dependencies: <list[dependency]> include_path: <list[path]> library_path: <list[path]> headers: <list[header]> libraries: <list[library]> compile_flags: <shell_args> link_flags: <shell_args> submodule_map: <submodule_map> # or... submodule_map: my_submodule: <submodule_map> '*': <submodule_map> auto_link optional, default : false version optional, default : null pcname optional, default : {my_pkg} dependencies optional, default : null include_path optional, default : null library_path optional, default : null headers optional, default : null libraries optional, default : null compile_flags optional, default : null link_flags optional, default : null See system usage.","title":"Packages"},{"location":"reference/packages/#packages","text":"Package configurations describe how to fetch a particular dependency as well as all the necessary details to actually use it in the parent project. packages: my_pkg: origin: <package_origin> inherit_defaults: <boolean> deploy: <boolean> submodules: <submodules> origin required The type of dependency, corresponding to a particular origin (e.g. a package manager); see below for possible values. inherit_defaults optional, default : false If true, inherit any unspecified values for this dependency from the defaults for the package. Defaults to false; however, any packages requested via mopack usage but not defined will use the defaults. deploy optional, default : true If true, deploy this package when calling mopack deploy . submodules optional, default : null A list of available submodules, or * to indicate that any submodule name should be accepted. If this is specified, using this package via mopack usage must specify a submodule. To declare that submodules are optional for usage, you can specify a dictionary: submodules: names: <submodules> required: false This can also be set in a package's export section.","title":"Packages"},{"location":"reference/packages/#source-distributions","text":"","title":"Source distributions"},{"location":"reference/packages/#directory","text":"packages: my_pkg: origin: directory path: <path> build: <build> usage: <usage> path required The path to the source directory of the dependency. build required The builder to use when resolving this package. Note that while this is required, it can be unset if the dependency defines the builder in its export section. usage optional, default : from builder The usage to use when using this package. Some builders require this to be set, but others provide a default usage specification; the dependency can also define the usage in its export section.","title":"directory"},{"location":"reference/packages/#git","text":"packages: my_pkg: origin: git repository: <url | path> tag: <tag_name> # or... branch: <branch_name> # or... commit: <commit_sha> srcdir: <inner_path> build: <build> usage: <usage> repository required The URL or path to the repository. tag optional branch commit The tag, branch, or commit to check out. At most one of these may be specified. srcdir optional; default: . The directory within the repository containing the dependency's source code. build required The builder to use when resolving this package. Note that while this is required, it can be unset if the dependency defines the builder in its export section. usage optional, default: from builder The usage to use when using this package. Some builders require this to be set, but others provide a default usage specification; the dependency can also define the usage in its export section.","title":"git"},{"location":"reference/packages/#tarball","text":"packages: my_pkg: origin: tarball path: <path> # or... url: <url> files: <list[glob]> srcdir: <inner_path> patch: <path> build: <build> usage: <usage> path required url The path or URL to the archive. Exactly one of these must be specified. files optional; default: null A glob or list of globs to filter the files extracted from the archive. If unspecified, extract everything. srcdir optional; default: . The directory within the repository containing the dependency's source code. patch optional; default: null The path to a patch file to apply to the extract source files. build required The builder to use when resolving this package. Note that while this is required, it can be unset if the dependency defines the builder in its export section. usage optional, default: from builder The usage to use when using this package. Some builders require this to be set, but others provide a default usage specification; the dependency can also define the usage in its export section.","title":"tarball"},{"location":"reference/packages/#other-origins","text":"","title":"Other origins"},{"location":"reference/packages/#apt","text":"packages: my_pkg: origin: apt remote: <list[string]> repository: <string> usage: <usage> remote optional; default: lib{package}-dev The Apt package(s) to fetch when resolving this package. repository optional; default: null The Apt repository to fetch the package(s) from. If not specified, use the default repositories for the system. usage optional, default: system The usage to use when using this package.","title":"apt"},{"location":"reference/packages/#conan","text":"options: origins: conan: build: <list[string]> extra_args: <shell_args> build optional; default: null A string (or list of strings) of packages that Conan should explicitly build. This corresponds to --build={package} on the conan install command line for each {package} in the list. You can also specify all to build everything (equivalent to --build ). extra_args optional, default : null A list of extra arguments to pass to conan install . If a string is supplied, it will first be split according to POSIX shell rules. packages: my_pkg: origin: conan remote: <string> build: <boolean> options: my_option: <string | boolean> usage: <usage> remote required The specifier for the package in the Conan repository, e.g. zlib/1.2.13 . build optional; default: false True if the package should be built from source; false otherwise. options optional; default: {} A dictionary of options to pass to Conan; for example, you could pass shared: true to request a shared library configuration. usage optional, default: pkg_config The usage to use when using this package.","title":"conan"},{"location":"reference/packages/#system","text":"packages: my_pkg: origin: system auto_link: <boolean> version: <string> pcname: <string> dependencies: <list[dependency]> include_path: <list[path]> library_path: <list[path]> headers: <list[header]> libraries: <list[library]> compile_flags: <shell_args> link_flags: <shell_args> submodule_map: <submodule_map> # or... submodule_map: my_submodule: <submodule_map> '*': <submodule_map> auto_link optional, default : false version optional, default : null pcname optional, default : {my_pkg} dependencies optional, default : null include_path optional, default : null library_path optional, default : null headers optional, default : null libraries optional, default : null compile_flags optional, default : null link_flags optional, default : null See system usage.","title":"system"},{"location":"reference/usage/","text":"Usage \u00a7 Usage defines how to include a package in part of your build process. These definitions are used to generate a pkg-config .pc file (or to point to an existing one), which can then be used when compiling or linking your project. packages: my_pkg: # ... usage: <usage_type> # or... usage: type: <usage_type> inherit_defaults: <boolean> submodule_map: <submodule_map> # or... submodule_map: my_submodule: <submodule_map> '*': <submodule_map> type required The type of usage; see below for possible values. inherit_defaults optional, default : false If true, inherit any unspecified values for this usage from the defaults for the package. Defaults to false; however, any packages requested via mopack usage but not defined will use the defaults. submodule_map optional, default : null A mapping from submodule names to submodule-specific configuration; a key of '*' refers to all submodules. See below for possible values for each usage type. Usage results \u00a7 When calling mopack usage <dependency> , mopack will provide information about how to use that dependency in your project. At minimum, all dependencies will report the following information: name: <string> type: <usage_type> pcnames: <list[string]> pkg_config_path: <list[path]> name The name of the requested dependency. type The type of usage; see below for possible values. pcnames A list of pkg-config .pc file names, without the .pc extension. pkg_config_path A list of directories to add to pkg-config's search path to find the dependency's pkg-config .pc files. path/system \u00a7 packages: my_pkg: # ... usage: type: path # or ... type: system auto_link: <boolean> version: <string> pcname: <string> # system only dependencies: <list[dependency]> include_path: <list[path]> library_path: <list[path]> headers: <list[header]> libraries: <list[library]> compile_flags: <shell_args> link_flags: <shell_args> auto_link optional, default : false If true, the package requires a compiler that supports auto-link (e.g. MSVC). version optional, default : null An optional version string, corresponding to the Version field of a pkg-config .pc file. pcname optional, default : {my_pkg} The name of the pkg-config .pc file, without the extension. If submodules are required for this package, this instead defaults to null . If this file isn't found, use the other options to generate a pkg-config file. dependencies optional, default : null A list of package dependencies that are required to use this package. This corresponds to the Requires field of a pkg-config .pc file. include_path optional, default : null A list of paths to search for header files (as specified in headers ). Any paths that include the required headers will be used when compiling with this dependency. library_path optional, default : null A list of paths to search for library files (as specified in libraries ). Any paths that include the required libraries will be used when linking with this dependency. headers optional, default : null A list of headers that must be found when searching include_path . This can generally be a single representative header file to detect that the dependency could actually be found. libraries optional, default : null A list of libary files to link to when using this dependency. compile_flags optional, default : null A list of extra flags to pass to the compiler when compiling with this dependency. link_flags optional, default : null A list of extra flags to pass to the linker when linking with this dependency. packages: my_pkg: # ... usage: # ... submodule_map: my_submodule: pcname: <string> # system only dependencies: <list[dependency]> include_path: <list[path]> library_path: <list[path]> headers: <list[header]> libraries: <list[library]> compile_flags: <shell_args> link_flags: <shell_args> pcname optional, default : {my_pkg} The name of the pkg-config .pc file, without the extension. If this file isn't found, use the other options to generate a pkg-config file. dependencies optional, default : null include_path optional, default : null library_path optional, default : null headers optional, default : null libraries optional, default : null compile_flags optional, default : null link_flags optional, default : null As above. Usage results \u00a7 In addition to the required usage results data, path / system usage results can include the following extra data: generated: <boolean> auto_link: <boolean> generated If true, the pkg-config .pc files for this dependency were automatically generated by mopack. If this property isn't included, then the .pc files were not autogenerated. auto_link : If true, the dependency expects your compiler to take advantage of auto-linking . (For example, Boost uses this when building with Microsoft or Borland compilers.) pkg_config \u00a7 packages: my_pkg: # ... usage: type: pkg_config pcname: <string> pkg_config_path: <list[path]> pcname optional, default : {my_pkg} The name of the pkg-config .pc file, without the extension. If submodules are required for this package, this instead defaults to null . pkg_config_path optional, default : null The path to look for the pkg-config file in. If not specified, use the default path for pkg-config. packages: my_pkg: # ... usage: # ... submodule_map: my_submodule: pcname: <string> pcname optional, default : {my_pkg}_{my_submodule} The name of the pkg-config .pc file for the submodule, without the extension.","title":"Usage"},{"location":"reference/usage/#usage","text":"Usage defines how to include a package in part of your build process. These definitions are used to generate a pkg-config .pc file (or to point to an existing one), which can then be used when compiling or linking your project. packages: my_pkg: # ... usage: <usage_type> # or... usage: type: <usage_type> inherit_defaults: <boolean> submodule_map: <submodule_map> # or... submodule_map: my_submodule: <submodule_map> '*': <submodule_map> type required The type of usage; see below for possible values. inherit_defaults optional, default : false If true, inherit any unspecified values for this usage from the defaults for the package. Defaults to false; however, any packages requested via mopack usage but not defined will use the defaults. submodule_map optional, default : null A mapping from submodule names to submodule-specific configuration; a key of '*' refers to all submodules. See below for possible values for each usage type.","title":"Usage"},{"location":"reference/usage/#usage-results","text":"When calling mopack usage <dependency> , mopack will provide information about how to use that dependency in your project. At minimum, all dependencies will report the following information: name: <string> type: <usage_type> pcnames: <list[string]> pkg_config_path: <list[path]> name The name of the requested dependency. type The type of usage; see below for possible values. pcnames A list of pkg-config .pc file names, without the .pc extension. pkg_config_path A list of directories to add to pkg-config's search path to find the dependency's pkg-config .pc files.","title":"Usage results"},{"location":"reference/usage/#path-system","text":"packages: my_pkg: # ... usage: type: path # or ... type: system auto_link: <boolean> version: <string> pcname: <string> # system only dependencies: <list[dependency]> include_path: <list[path]> library_path: <list[path]> headers: <list[header]> libraries: <list[library]> compile_flags: <shell_args> link_flags: <shell_args> auto_link optional, default : false If true, the package requires a compiler that supports auto-link (e.g. MSVC). version optional, default : null An optional version string, corresponding to the Version field of a pkg-config .pc file. pcname optional, default : {my_pkg} The name of the pkg-config .pc file, without the extension. If submodules are required for this package, this instead defaults to null . If this file isn't found, use the other options to generate a pkg-config file. dependencies optional, default : null A list of package dependencies that are required to use this package. This corresponds to the Requires field of a pkg-config .pc file. include_path optional, default : null A list of paths to search for header files (as specified in headers ). Any paths that include the required headers will be used when compiling with this dependency. library_path optional, default : null A list of paths to search for library files (as specified in libraries ). Any paths that include the required libraries will be used when linking with this dependency. headers optional, default : null A list of headers that must be found when searching include_path . This can generally be a single representative header file to detect that the dependency could actually be found. libraries optional, default : null A list of libary files to link to when using this dependency. compile_flags optional, default : null A list of extra flags to pass to the compiler when compiling with this dependency. link_flags optional, default : null A list of extra flags to pass to the linker when linking with this dependency. packages: my_pkg: # ... usage: # ... submodule_map: my_submodule: pcname: <string> # system only dependencies: <list[dependency]> include_path: <list[path]> library_path: <list[path]> headers: <list[header]> libraries: <list[library]> compile_flags: <shell_args> link_flags: <shell_args> pcname optional, default : {my_pkg} The name of the pkg-config .pc file, without the extension. If this file isn't found, use the other options to generate a pkg-config file. dependencies optional, default : null include_path optional, default : null library_path optional, default : null headers optional, default : null libraries optional, default : null compile_flags optional, default : null link_flags optional, default : null As above.","title":"path/system"},{"location":"reference/usage/#path-system-usage-results","text":"In addition to the required usage results data, path / system usage results can include the following extra data: generated: <boolean> auto_link: <boolean> generated If true, the pkg-config .pc files for this dependency were automatically generated by mopack. If this property isn't included, then the .pc files were not autogenerated. auto_link : If true, the dependency expects your compiler to take advantage of auto-linking . (For example, Boost uses this when building with Microsoft or Borland compilers.)","title":"Usage results"},{"location":"reference/usage/#pkg_config","text":"packages: my_pkg: # ... usage: type: pkg_config pcname: <string> pkg_config_path: <list[path]> pcname optional, default : {my_pkg} The name of the pkg-config .pc file, without the extension. If submodules are required for this package, this instead defaults to null . pkg_config_path optional, default : null The path to look for the pkg-config file in. If not specified, use the default path for pkg-config. packages: my_pkg: # ... usage: # ... submodule_map: my_submodule: pcname: <string> pcname optional, default : {my_pkg}_{my_submodule} The name of the pkg-config .pc file for the submodule, without the extension.","title":"pkg_config"},{"location":"user/resolving/","text":"Resolving Packages With mopack \u00a7 Most package managers allow developers to pull dependencies from a remote origin and prepare them for use by your build system. In this regard, mopack is no different. Note mopack is careful not to use the term \"install\"; depending on context, installation can refer to one of two very-different concepts: Resolve : to fetch a dependency from its origin and prepare it (usually by building) for use by the root project (e.g. conan install ) Deploy : to copy any files from the dependency needed for running the root project into their final locations (e.g. make install ) Resolution \u00a7 The first step in working with dependencies is, unsurprisingly, getting them. This is really two sub-steps rolled into one: fetching and building. This typically involves downloading the appropriate files from some remote origin (possibly recursively in the case of source distributions ) and then compiling any projects as needed in the proper order, using their respective build systems. In most cases, this step should occur before configuration of the root project's build (for build configuration systems that natively support mopack, such as bfg9000 , this happens automatically). However, when run manually, users should invoke the following command: $ mopack resolve /path/to/project/ This will get all the dependencies specified in /path/to/project/mopack.yml and collect the info necessary to use them in ./mopack/ . If your build dir is not the current directory, you can specify another location with --directory /path/to/builddir/ . You can also specify multiple paths when resolving, including specific filenames: $ mopack resolve . mopack-special.yml This can be useful for providing alternate configurations or for adding mopack configurations automatically generated by a tool. Note Packages and options specified in later files override previous values. Local configuration \u00a7 Projects that use mopack often contain their own mopack.yml configuration; however, when building such a project, you may not want to use this configuration (or may only want to use parts of it). In this case, you can provide your own mopack-local.yml file to override the project's configuration. When passing a directory to mopack resolve , mopack will look for both mopack.yml and mopack-local.yml , with any packages or options specified in the latter file will override those in the former. Thus, if both mopack.yml and mopack-local.yml exist, mopack resolve . is equivalent to: $ mopack resolve mopack.yml mopack-local.yml Usage \u00a7 Once a project's dependencies are ready to use, the next step is actually using them. Generally, this step occurs during the root project's configuration step. To get a package's usage information, run the following command: $ mopack usage some-package This will return the package's usage information in YAML format (or JSON if --json is passed), which can then be fed to the dependent build steps. Some packages contain submodules , representing optional components that you may or may not want to use (e.g. individual libraries from the Boost package). In this case, you can specify the submodules you want to use in a particular situation when invoking mopack usage : $ mopack usage 'some-package[submodule1,submodule2]' Deployment \u00a7 Finally, some projects may want to deploy dependencies alongside the project's own binaries (e.g. when running make install ). This step (generally performed during the root project's make install process, naturally) runs whatever commands are necessary for each dependency to deploy them to the final destination: $ mopack deploy Any dependency whose deploy property is true (the default) will then be deployed.","title":"Resolving Packages With mopack"},{"location":"user/resolving/#resolving-packages-with-mopack","text":"Most package managers allow developers to pull dependencies from a remote origin and prepare them for use by your build system. In this regard, mopack is no different. Note mopack is careful not to use the term \"install\"; depending on context, installation can refer to one of two very-different concepts: Resolve : to fetch a dependency from its origin and prepare it (usually by building) for use by the root project (e.g. conan install ) Deploy : to copy any files from the dependency needed for running the root project into their final locations (e.g. make install )","title":"Resolving Packages With mopack"},{"location":"user/resolving/#resolution","text":"The first step in working with dependencies is, unsurprisingly, getting them. This is really two sub-steps rolled into one: fetching and building. This typically involves downloading the appropriate files from some remote origin (possibly recursively in the case of source distributions ) and then compiling any projects as needed in the proper order, using their respective build systems. In most cases, this step should occur before configuration of the root project's build (for build configuration systems that natively support mopack, such as bfg9000 , this happens automatically). However, when run manually, users should invoke the following command: $ mopack resolve /path/to/project/ This will get all the dependencies specified in /path/to/project/mopack.yml and collect the info necessary to use them in ./mopack/ . If your build dir is not the current directory, you can specify another location with --directory /path/to/builddir/ . You can also specify multiple paths when resolving, including specific filenames: $ mopack resolve . mopack-special.yml This can be useful for providing alternate configurations or for adding mopack configurations automatically generated by a tool. Note Packages and options specified in later files override previous values.","title":"Resolution"},{"location":"user/resolving/#local-configuration","text":"Projects that use mopack often contain their own mopack.yml configuration; however, when building such a project, you may not want to use this configuration (or may only want to use parts of it). In this case, you can provide your own mopack-local.yml file to override the project's configuration. When passing a directory to mopack resolve , mopack will look for both mopack.yml and mopack-local.yml , with any packages or options specified in the latter file will override those in the former. Thus, if both mopack.yml and mopack-local.yml exist, mopack resolve . is equivalent to: $ mopack resolve mopack.yml mopack-local.yml","title":"Local configuration"},{"location":"user/resolving/#usage","text":"Once a project's dependencies are ready to use, the next step is actually using them. Generally, this step occurs during the root project's configuration step. To get a package's usage information, run the following command: $ mopack usage some-package This will return the package's usage information in YAML format (or JSON if --json is passed), which can then be fed to the dependent build steps. Some packages contain submodules , representing optional components that you may or may not want to use (e.g. individual libraries from the Boost package). In this case, you can specify the submodules you want to use in a particular situation when invoking mopack usage : $ mopack usage 'some-package[submodule1,submodule2]'","title":"Usage"},{"location":"user/resolving/#deployment","text":"Finally, some projects may want to deploy dependencies alongside the project's own binaries (e.g. when running make install ). This step (generally performed during the root project's make install process, naturally) runs whatever commands are necessary for each dependency to deploy them to the final destination: $ mopack deploy Any dependency whose deploy property is true (the default) will then be deployed.","title":"Deployment"},{"location":"user/writing/","text":"Writing mopack.yml Configurations \u00a7 Your first configuration \u00a7 The absolute simplest mopack configuration is an empty file, in which any requested dependencies are assumed to be system dependencies . However, that's not very interesting. Instead, let's look at a basic mopack.yml configuration that specifies a dependent package fetched and built from a tarball: packages: foo_pkg: origin: tarball url: https://phobos.uac/foo_pkg-1.0.tar.gz build: bfg9000 This informs mopack that it should fetch a tarball from the specified URL and then build it using the bfg9000 builder. Configuring builds/usage \u00a7 In the above example, mopack builds foo_pkg using the default settings for bfg9000. However, sometimes you may need to provide additional configuration options for the build: packages: foo_pkg: origin: tarball url: https://phobos.uac/foo_pkg-1.0.tar.gz build: type: bfg9000 extra_args: --extra usage: type: pkg_config pcname: foobar Here, instead of a string for build , we specify a dictionary indicating the type of the build and some extra arguments to be passed to it. Below, we'll show a more complex example taking advantage of variable interpolation . We also explicitly specify a usage . A usage, as the name implies, describes how a package should be used , e.g. where to find header files, what libraries to link to, etc. Other package origins \u00a7 One of the primary benefits of mopack is that packages can come from multiple different origins, or sources. These include other source distributions similar to tarball , such as directory or git , as well as full-fledged package managers like apt or conan : packages: zlib: origin: conan remote: zlib/1.2.13 Project-wide options \u00a7 In addition to specifying configuration options for a particular package, you can also specify options for all packages, or all those of a particular type: options: target_platform: linux builders: bfg9000: toolchain: /path/to/toolchain.bfg origins: conan: build: missing packages: # ... This is especially useful for build system integration, e.g. for passing a toolchain file set during configuration of the root project on to package dependencies. Nested dependencies \u00a7 When your project depends on a source distribution, that dependency might depend on other packages in turn. mopack handles this automatically, and will add nested dependencies to the list of packages to resolve. For example, if foo_pkg above contains a mopack.yml as follows, then when we resolve our main mopack.yml configuration, bar_pkg will be fetched and built so that foo_pkg can use it during its build: packages: bar_pkg: origin: tarball url: https://phobos.uac/bar_pkg-2.0.tar.gz build: bfg9000 Overriding nested dependencies \u00a7 Sometimes, you may not want to use the nested dependencies as-is from other packages. In this case, you can simply provide your own configuration in the parent mopack.yml : packages: foo_pkg: origin: tarball url: https://phobos.uac/foo_pkg-1.0.tar.gz build: bfg9000 bar_pkg: origin: tarball url: https://phobos.uac/bar_pkg-2.1.tar.gz build: bfg9000 When doing so, mopack will automatically determine the appropriate order to build dependencies so that each package has all of its build requirements met. Note In situations where one package depends on another, but the former package does not specify any mopack dependencies, you can ensure the correct build order by putting the inner dependency first in your mopack.yml file. Then, mopack will fetch and build that package first before proceeding to the next one. Exporting package configuration \u00a7 When creating a source distribution package, you can make it easier to use this package by exporting its configuration. This allows users of your package to omit the details about how to build and use the package. For example, you can include the following in your package's mopack.yml file: export: build: bfg9000 Then, users of your package can omit those fields from their configuration, relying on mopack to fill in the blanks: packages: foo_pkg: origin: tarball url: https://phobos.uac/foo_pkg-1.0.tar.gz Of course, the parent configuration can still override the values set by a dependency simply by including the appropriate configuration setting, as in our first example . Variable interpolation \u00a7 For more advanced scenarios, you can take advantage of variable interpolation to programmatically specify package configurations. For example, suppose we wanted to (partially) rewrite our first configuration using a custom builder: packages: foo_pkg: origin: tarball url: https://phobos.uac/foo_pkg-1.0.tar.gz build: type: custom build_commands: - bfg9000 configure $builddir - cd $builddir - ninja usage: pkg_config Here, $builddir represents a unique path for the current project that it can use as a build directory. You can also spell this variable as ${{builddir}} , which can be useful if you need to append some alphanumeric characters to the variable's value. Interpolating expressions \u00a7 The above configuration works for building a package, but not for deploying it: we haven't told the build system where to copy foo_pkg 's files. Here, we can take advantage of expression interpolation to conditionally pass command line arguments to bfg9000: packages: foo_pkg: origin: tarball url: https://phobos.uac/foo_pkg-1.0.tar.gz build: type: custom build_commands: - >- bfg9000 configure $builddir ${{ deploy_dirs['prefix'] ? '--prefix=' + deploy_dirs['prefix'] : '' }} - cd $builddir/. - ninja deploy_commands: - ninja install usage: pkg_config Conditional package specification \u00a7 In some cases, a package's configuration should be much different depending on the state of a variable, and the variable interpolation described above isn't flexible enough to support this easily. To support this, a package's configuration can be specified as a list of configurations with an added if key to describe the conditions to use a particular configuration. Note that, since if always takes an expression, the $ / ${{ }} sigil is not required: packages: foo_pkg: - if: host_platform == 'linux' origin: apt - origin: tarball url: https://phobos.uac/foo_pkg-1.0.tar.gz build: bfg9000 The conditional for each configuration is evaluated in turn, selecting the first configuration where its conditional is true. If the last configuration has no if key, it will always be selected as a last resort; otherwise, if no conditional is satisfied, the package will be undefined. Submodules \u00a7 In mopack, a \"package\" represents a single unit distributed in its most-typical form. Thus Boost, despite containing a wide variety of libraries, is still a single package. However, for a package like Boost, users rarely need to use the entirety of the package. In this case, a package can be divided into submodules. A submodule represents the smallest usable unit of a package; in Boost's case, a single Boost library. At its simplest, defining submodules for a package consists of listing the available submodule names: packages: hello: origin: tarball path: greeter-1.0.tar.gz build: bfg9000 submodules: ['french', 'english'] This specifies a package with two submodules, requiring at least one to be specified whenever mopack usage is invoked.","title":"Writing mopack.yml Configurations"},{"location":"user/writing/#writing-mopackyml-configurations","text":"","title":"Writing mopack.yml Configurations"},{"location":"user/writing/#your-first-configuration","text":"The absolute simplest mopack configuration is an empty file, in which any requested dependencies are assumed to be system dependencies . However, that's not very interesting. Instead, let's look at a basic mopack.yml configuration that specifies a dependent package fetched and built from a tarball: packages: foo_pkg: origin: tarball url: https://phobos.uac/foo_pkg-1.0.tar.gz build: bfg9000 This informs mopack that it should fetch a tarball from the specified URL and then build it using the bfg9000 builder.","title":"Your first configuration"},{"location":"user/writing/#configuring-buildsusage","text":"In the above example, mopack builds foo_pkg using the default settings for bfg9000. However, sometimes you may need to provide additional configuration options for the build: packages: foo_pkg: origin: tarball url: https://phobos.uac/foo_pkg-1.0.tar.gz build: type: bfg9000 extra_args: --extra usage: type: pkg_config pcname: foobar Here, instead of a string for build , we specify a dictionary indicating the type of the build and some extra arguments to be passed to it. Below, we'll show a more complex example taking advantage of variable interpolation . We also explicitly specify a usage . A usage, as the name implies, describes how a package should be used , e.g. where to find header files, what libraries to link to, etc.","title":"Configuring builds/usage"},{"location":"user/writing/#other-package-origins","text":"One of the primary benefits of mopack is that packages can come from multiple different origins, or sources. These include other source distributions similar to tarball , such as directory or git , as well as full-fledged package managers like apt or conan : packages: zlib: origin: conan remote: zlib/1.2.13","title":"Other package origins"},{"location":"user/writing/#project-wide-options","text":"In addition to specifying configuration options for a particular package, you can also specify options for all packages, or all those of a particular type: options: target_platform: linux builders: bfg9000: toolchain: /path/to/toolchain.bfg origins: conan: build: missing packages: # ... This is especially useful for build system integration, e.g. for passing a toolchain file set during configuration of the root project on to package dependencies.","title":"Project-wide options"},{"location":"user/writing/#nested-dependencies","text":"When your project depends on a source distribution, that dependency might depend on other packages in turn. mopack handles this automatically, and will add nested dependencies to the list of packages to resolve. For example, if foo_pkg above contains a mopack.yml as follows, then when we resolve our main mopack.yml configuration, bar_pkg will be fetched and built so that foo_pkg can use it during its build: packages: bar_pkg: origin: tarball url: https://phobos.uac/bar_pkg-2.0.tar.gz build: bfg9000","title":"Nested dependencies"},{"location":"user/writing/#overriding-nested-dependencies","text":"Sometimes, you may not want to use the nested dependencies as-is from other packages. In this case, you can simply provide your own configuration in the parent mopack.yml : packages: foo_pkg: origin: tarball url: https://phobos.uac/foo_pkg-1.0.tar.gz build: bfg9000 bar_pkg: origin: tarball url: https://phobos.uac/bar_pkg-2.1.tar.gz build: bfg9000 When doing so, mopack will automatically determine the appropriate order to build dependencies so that each package has all of its build requirements met. Note In situations where one package depends on another, but the former package does not specify any mopack dependencies, you can ensure the correct build order by putting the inner dependency first in your mopack.yml file. Then, mopack will fetch and build that package first before proceeding to the next one.","title":"Overriding nested dependencies"},{"location":"user/writing/#exporting-package-configuration","text":"When creating a source distribution package, you can make it easier to use this package by exporting its configuration. This allows users of your package to omit the details about how to build and use the package. For example, you can include the following in your package's mopack.yml file: export: build: bfg9000 Then, users of your package can omit those fields from their configuration, relying on mopack to fill in the blanks: packages: foo_pkg: origin: tarball url: https://phobos.uac/foo_pkg-1.0.tar.gz Of course, the parent configuration can still override the values set by a dependency simply by including the appropriate configuration setting, as in our first example .","title":"Exporting package configuration"},{"location":"user/writing/#variable-interpolation","text":"For more advanced scenarios, you can take advantage of variable interpolation to programmatically specify package configurations. For example, suppose we wanted to (partially) rewrite our first configuration using a custom builder: packages: foo_pkg: origin: tarball url: https://phobos.uac/foo_pkg-1.0.tar.gz build: type: custom build_commands: - bfg9000 configure $builddir - cd $builddir - ninja usage: pkg_config Here, $builddir represents a unique path for the current project that it can use as a build directory. You can also spell this variable as ${{builddir}} , which can be useful if you need to append some alphanumeric characters to the variable's value.","title":"Variable interpolation"},{"location":"user/writing/#interpolating-expressions","text":"The above configuration works for building a package, but not for deploying it: we haven't told the build system where to copy foo_pkg 's files. Here, we can take advantage of expression interpolation to conditionally pass command line arguments to bfg9000: packages: foo_pkg: origin: tarball url: https://phobos.uac/foo_pkg-1.0.tar.gz build: type: custom build_commands: - >- bfg9000 configure $builddir ${{ deploy_dirs['prefix'] ? '--prefix=' + deploy_dirs['prefix'] : '' }} - cd $builddir/. - ninja deploy_commands: - ninja install usage: pkg_config","title":"Interpolating expressions"},{"location":"user/writing/#conditional-package-specification","text":"In some cases, a package's configuration should be much different depending on the state of a variable, and the variable interpolation described above isn't flexible enough to support this easily. To support this, a package's configuration can be specified as a list of configurations with an added if key to describe the conditions to use a particular configuration. Note that, since if always takes an expression, the $ / ${{ }} sigil is not required: packages: foo_pkg: - if: host_platform == 'linux' origin: apt - origin: tarball url: https://phobos.uac/foo_pkg-1.0.tar.gz build: bfg9000 The conditional for each configuration is evaluated in turn, selecting the first configuration where its conditional is true. If the last configuration has no if key, it will always be selected as a last resort; otherwise, if no conditional is satisfied, the package will be undefined.","title":"Conditional package specification"},{"location":"user/writing/#submodules","text":"In mopack, a \"package\" represents a single unit distributed in its most-typical form. Thus Boost, despite containing a wide variety of libraries, is still a single package. However, for a package like Boost, users rarely need to use the entirety of the package. In this case, a package can be divided into submodules. A submodule represents the smallest usable unit of a package; in Boost's case, a single Boost library. At its simplest, defining submodules for a package consists of listing the available submodule names: packages: hello: origin: tarball path: greeter-1.0.tar.gz build: bfg9000 submodules: ['french', 'english'] This specifies a package with two submodules, requiring at least one to be specified whenever mopack usage is invoked.","title":"Submodules"}]}